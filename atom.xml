<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Surly 的 blog</title>
  
  <subtitle>it is ok</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://surlyyoung.github.io/"/>
  <updated>2019-03-11T03:17:34.359Z</updated>
  <id>https://surlyyoung.github.io/</id>
  
  <author>
    <name>Surly Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>About-es6-Module</title>
    <link href="https://surlyyoung.github.io/2019/03/08/About-es6-Module/"/>
    <id>https://surlyyoung.github.io/2019/03/08/About-es6-Module/</id>
    <published>2019-03-08T07:58:25.000Z</published>
    <updated>2019-03-11T03:17:34.359Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Link</a></h3><h2 id="Module语法及背景"><a href="#Module语法及背景" class="headerlink" title="Module语法及背景"></a>Module语法及背景</h2><blockquote><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。<br>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p></blockquote><blockquote><p>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。</p></blockquote><blockquote><p>import只加载指定的方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p></blockquote><blockquote><p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p></blockquote><a id="more"></a><blockquote><p>ES6 的模块自动采用严格模式，严格模式主要有以下限制</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li>eval不会在它的外层作用域引入变量</li><li>eval和arguments不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象 !!!!!!!!!!!!</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface</li></ul></blockquote><h2 id="module总结"><a href="#module总结" class="headerlink" title="module总结"></a>module总结</h2><h3 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h3><blockquote><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p></blockquote><h4 id="export写法"><a href="#export写法" class="headerlink" title="export写法"></a>export写法</h4><ol><li><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> var firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="built_in">export</span> var lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="built_in">export</span> var year = 1958;</span><br></pre></td></tr></table></figure></li><li><p>推荐</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var firstName = <span class="string">'Michael'</span>;</span><br><span class="line">var lastName = <span class="string">'Jackson'</span>;</span><br><span class="line">var year = 1958;</span><br><span class="line"><span class="built_in">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>export命令后面，使用大括号( 直接跟着export则不用大括号 ！)指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p></blockquote><blockquote><p>export命令除了输出变量，还可以输出函数或类（class）。</p></blockquote><blockquote><p>通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名</p></blockquote><blockquote><p>export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值,CommonJS 模块输出的是值的缓存，不存在动态更新</p></blockquote><blockquote><p>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  <span class="built_in">export</span> default <span class="string">'bar'</span> // SyntaxError</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h3><h4 id="import写法"><a href="#import写法" class="headerlink" title="import写法"></a>import写法</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;firstName, lastName, year&#125; from <span class="string">'./profile.js'</span>;</span><br><span class="line"><span class="keyword">function</span> setName(element) &#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</p></blockquote><blockquote><p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lastName as surname &#125; from <span class="string">'./profile.js'</span>;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。但是，如果a是一个对象，改写a的属性是允许的。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。</p></blockquote><blockquote><p>import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p></blockquote><blockquote><p>import命令具有提升效果，会提升到整个模块的头部，首先执行。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。</p></blockquote><blockquote><p>由于import是静态执行，所以不能使用表达式和变量或if结构，这些只有在运行时才能得到结果的语法结构。</p></blockquote><blockquote><p>import语句会执行所加载的模块，因此可以有下面的写法。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; foo &#125; from <span class="string">'my_module'</span>;</span><br><span class="line">import &#123; bar &#125; from <span class="string">'my_module'</span>;</span><br><span class="line">// 等同于</span><br><span class="line">import &#123; foo, bar &#125; from <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式</p></blockquote><blockquote><p>通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的</p></blockquote><h4 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// circle.js</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> area(radius) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> circumference(radius) &#123;</span><br><span class="line">  <span class="built_in">return</span> 2 * Math.PI * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import * as circle from <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'圆面积：'</span> + circle.area(4));</span><br><span class="line">console.log(<span class="string">'圆周长：'</span> + circle.circumference(14));</span><br><span class="line"></span><br><span class="line">//模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</span><br><span class="line">import * as circle from <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line">// 下面两行都是不允许的</span><br><span class="line">circle.foo = <span class="string">'hello'</span>;</span><br><span class="line">circle.area = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h4><ul><li>至此使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载；</li><li>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</li><li>可以用任意名称指向expor default输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。</li><li>export default命令用在非匿名函数前，也是可以的，但函数名对外无效，加载的时候，视同匿名函数加载。</li><li>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令</li><li>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</li><li>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句</li><li><p>如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _, &#123; each, forEach &#125; from <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure></li><li><p>export default也可以用来输出类</p></li></ul><h4 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h4><ul><li>在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; foo, bar &#125; from <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line">// 可以简单理解为</span><br><span class="line">import &#123; foo, bar &#125; from <span class="string">'my_module'</span>;</span><br><span class="line"><span class="built_in">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar</strong></p><blockquote><p>模块的接口改名和整体输出，也可以采用这种写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 接口改名</span><br><span class="line">export &#123; foo as myFoo &#125; from &apos;my_module&apos;;</span><br><span class="line">// 整体输出</span><br><span class="line">export * from &apos;my_module&apos;;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h4><blockquote><p>模块之间也可以继承</p></blockquote><h4 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h4><p>const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// constants.js 模块</span><br><span class="line"><span class="built_in">export</span> const A = 1;</span><br><span class="line"><span class="built_in">export</span> const B = 3;</span><br><span class="line"><span class="built_in">export</span> const C = 4;</span><br><span class="line"></span><br><span class="line">// test1.js 模块</span><br><span class="line">import * as constants from <span class="string">'./constants'</span>;</span><br><span class="line">console.log(constants.A); // 1</span><br><span class="line">console.log(constants.B); // 3</span><br><span class="line"></span><br><span class="line">// test2.js 模块</span><br><span class="line">import &#123;A, B&#125; from <span class="string">'./constants'</span>;</span><br><span class="line">console.log(A); // 1</span><br><span class="line">console.log(B); // 3</span><br></pre></td></tr></table></figure></p><p>如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// constants/db.js</span><br><span class="line"><span class="built_in">export</span> const db = &#123;</span><br><span class="line">  url: <span class="string">'http://my.couchdbserver.local:5984'</span>,</span><br><span class="line">  admin_username: <span class="string">'admin'</span>,</span><br><span class="line">  admin_password: <span class="string">'admin password'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// constants/user.js</span><br><span class="line"><span class="built_in">export</span> const users = [<span class="string">'root'</span>, <span class="string">'admin'</span>, <span class="string">'staff'</span>, <span class="string">'ceo'</span>, <span class="string">'chief'</span>, <span class="string">'moderator'</span>];</span><br></pre></td></tr></table></figure></p><p>然后，将这些文件输出的常量，合并在index.js里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// constants/index.js</span><br><span class="line">export &#123;db&#125; from &apos;./db&apos;;</span><br><span class="line">export &#123;users&#125; from &apos;./users&apos;;</span><br></pre></td></tr></table></figure></p><p>使用的时候，直接加载index.js就可以了。<br><code>import {db, users} from &#39;./constants/index&#39;;</code></p><h4 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h4><blockquote><p>import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">if (x === 2) &#123;</span><br><span class="line">  import MyModual from &apos;./myModual&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中(比如，在if代码块之中，或在函数之中)<br>因为require是运行时加载模块，import命令无法取代require的动态加载功能  </p></blockquote><blockquote><p>引入import()函数，完成动态加载<br>import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。<br>import()返回一个 Promise 对象</p></blockquote><blockquote><p>import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块<br>import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。<br>import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。</p></blockquote><p><strong>import()的一些适用场合</strong></p><ol><li>按需加载<br>import()可以在需要的时候，再加载某个模块。</li><li>条件加载<br>import()可以放在if代码块，根据不同的情况，加载不同的模块</li><li>动态的模块路径<br>import()允许模块路径动态生成</li></ol><p><strong>注意点</strong></p><blockquote><p>import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口,如果模块有default输出接口，可以用参数直接获得</p></blockquote><blockquote><p>如果想同时加载多个模块，可以采用下面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([</span><br><span class="line">  import(&apos;./module1.js&apos;),</span><br><span class="line">  import(&apos;./module2.js&apos;),</span><br><span class="line">  import(&apos;./module3.js&apos;),</span><br><span class="line">])</span><br><span class="line">.then(([module1, module2, module3]) =&gt; &#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>import()也可以用在 async 函数之中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">  const myModule = await import(&apos;./myModule.js&apos;);</span><br><span class="line">  const &#123;export1, export2&#125; = await import(&apos;./myModule.js&apos;);</span><br><span class="line">  const [module1, module2, module3] =</span><br><span class="line">    await Promise.all([</span><br><span class="line">      import(&apos;./module1.js&apos;),</span><br><span class="line">      import(&apos;./module2.js&apos;),</span><br><span class="line">      import(&apos;./module3.js&apos;),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/module&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;Module语法及背景&quot;&gt;&lt;a href=&quot;#Module语法及背景&quot; class=&quot;headerlink&quot; title=&quot;Module语法及背景&quot;&gt;&lt;/a&gt;Module语法及背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。&lt;br&gt;ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import只加载指定的方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About-es6-数组的扩展总结</title>
    <link href="https://surlyyoung.github.io/2019/03/06/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%BB%E7%BB%93/"/>
    <id>https://surlyyoung.github.io/2019/03/06/数组的扩展总结/</id>
    <published>2019-03-06T08:50:32.000Z</published>
    <updated>2019-03-11T03:22:40.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="noopener">Link</a></h3><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><blockquote><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列<br>该运算符主要用于函数调用。将一个数组，变为参数序列<br>扩展运算符与正常的函数参数可以结合使用，非常灵活。<br>扩展运算符后面还可以放置表达式。<br>如果扩展运算符后面是一个空数组，则不产生任何效果。<br>扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。</p></blockquote><a id="more"></a><h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h3><p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ES5 的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure></p><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><ol><li>复制数组<blockquote><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。<br>ES5 只能用变通方法来复制数组。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[0] = 2;</span><br><span class="line">a1 // [1, 2]</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>扩展运算符提供了复制数组的简便写法。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">// 写法一</span><br><span class="line">const a2 = [...a1];</span><br><span class="line">// 写法二</span><br><span class="line">const [...a2] = a1;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>合并数组<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">const arr2 = [<span class="string">'c'</span>];</span><br><span class="line">const arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">// ES5 的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br><span class="line"></span><br><span class="line">// ES6 的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br></pre></td></tr></table></figure></li></ol><p>不过，这两种方法都是浅拷贝(只能复制简单的数据格式)，使用的时候需要注意。</p><ol start="3"><li><p>与解构赋值结合<br>扩展运算符可以与解构赋值结合起来，用于生成数组</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [];</span><br><span class="line">first // undefined</span><br><span class="line">rest  // []</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [<span class="string">"foo"</span>]; //...rest只能放在最后一位</span><br><span class="line">first  // <span class="string">"foo"</span></span><br><span class="line">rest   // []</span><br></pre></td></tr></table></figure></li><li><p>使字符串变成数组</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line">// [ <span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span> ]</span><br></pre></td></tr></table></figure></li><li><p>实现了 Iterator 接口的对象<br>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组</p></li><li>Map 和 Set 结构，Generator 函数<br>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</li></ol><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><blockquote><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line"><span class="built_in">let</span> arr2 = Array.from(arrayLike); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// NodeList对象</span><br><span class="line"><span class="built_in">let</span> ps = document.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line">Array.from(ps).filter(p =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> p.textContent.length &gt; 100;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// arguments对象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var args = Array.from(arguments);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组<br>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const toArray = (() =&gt;</span><br><span class="line">  Array.from ? Array.from : obj =&gt; [].slice.call(obj)</span><br><span class="line">)();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</span><br><span class="line">// [1, 4, 9]</span><br></pre></td></tr></table></figure></p></blockquote><p>将数组中布尔值为false的成员转为0。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, , 2, , 3], (n) =&gt; n || 0)</span><br><span class="line">// [1, 0, 2, 0, 3]</span><br></pre></td></tr></table></figure></p><p>另一个例子是返回各种数据的类型。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">typesOf</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(arguments, value =&gt; typeof value)</span><br><span class="line">&#125;</span><br><span class="line">typesOf(null, [], NaN)</span><br><span class="line">// [<span class="string">'object'</span>, <span class="string">'object'</span>, <span class="string">'number'</span>]</span><br></pre></td></tr></table></figure></p><blockquote><p>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。<br>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。</p></blockquote><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><blockquote><p>Array.of方法用于将一组值，转换为数组。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br></pre></td></tr></table></figure></p></blockquote><p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure></p><p>Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p><blockquote><p>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一</p></blockquote><h2 id="数组实例的-copyWithin"><a href="#数组实例的-copyWithin" class="headerlink" title="数组实例的 copyWithin()"></a>数组实例的 copyWithin()</h2><blockquote><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.copyWithin(target, start = 0, end = this.length)</span><br><span class="line">// 将3号位复制到0号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4)</span><br><span class="line">// [4, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>它接受三个参数。<br>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。<br>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值。</p></blockquote><h2 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find() 和 findIndex()"></a>数组实例的 find() 和 findIndex()</h2><blockquote><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br><span class="line">[1, 5, 10, 15].find(<span class="keyword">function</span>(value, index, arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> value &gt; 9;</span><br><span class="line">&#125;) // 10</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p></blockquote><blockquote><p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].findIndex(<span class="keyword">function</span>(value, index, arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure></p></blockquote><p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(v)&#123;</span><br><span class="line">  <span class="built_in">return</span> v &gt; this.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> person = &#123;name: <span class="string">'John'</span>, age: 20&#125;;</span><br><span class="line">[10, 12, 26, 15].find(f, person);    // 26</span><br></pre></td></tr></table></figure></p><blockquote><p>这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足</p></blockquote><h2 id="数组实例的-fill"><a href="#数组实例的-fill" class="headerlink" title="数组实例的 fill()"></a>数组实例的 fill()</h2><p>fill方法使用给定值，填充一个数组。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure></p><blockquote><p>fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。<br>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置<br>如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p></blockquote><h2 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys() 和 values()"></a>数组实例的 entries()，keys() 和 values()</h2><blockquote><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index of [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> elem of [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">'a'</span></span><br><span class="line">// <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [index, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 <span class="string">"a"</span></span><br><span class="line">// 1 <span class="string">"b"</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h2><blockquote><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2)     // <span class="literal">true</span></span><br><span class="line">[1, 2, 3].includes(4)     // <span class="literal">false</span></span><br><span class="line">[1, 2, NaN].includes(NaN) // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p></blockquote><blockquote><p>对比indexOf,indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;扩展运算符&quot;&gt;&lt;a href=&quot;#扩展运算符&quot; class=&quot;headerlink&quot; title=&quot;扩展运算符&quot;&gt;&lt;/a&gt;扩展运算符&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列&lt;br&gt;该运算符主要用于函数调用。将一个数组，变为参数序列&lt;br&gt;扩展运算符与正常的函数参数可以结合使用，非常灵活。&lt;br&gt;扩展运算符后面还可以放置表达式。&lt;br&gt;如果扩展运算符后面是一个空数组，则不产生任何效果。&lt;br&gt;扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About es6-函数的扩展</title>
    <link href="https://surlyyoung.github.io/2019/03/06/About-es6-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://surlyyoung.github.io/2019/03/06/About-es6-函数的扩展/</id>
    <published>2019-03-06T03:21:50.000Z</published>
    <updated>2019-03-06T07:43:48.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="noopener">Link</a></h3><h4 id="遗留问题-this"><a href="#遗留问题-this" class="headerlink" title="遗留问题 (this)"></a>遗留问题 (this)</h4><h2 id="函数的扩展总结"><a href="#函数的扩展总结" class="headerlink" title="函数的扩展总结"></a>函数的扩展总结</h2><ul><li><p>基本用法</p><blockquote><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面<br>参数变量是默认声明的，在函数体中，不能用let或const再次声明。<br>使用参数默认值时，函数不能有同名参数。<br>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p></blockquote></li><li><p>与解构赋值默认值结合使用</p></li></ul><a id="more"></a><blockquote><p>参数默认值可以与解构赋值的默认值，结合起来使用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo(&#123;&#125;) // undefined 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1 2</span><br><span class="line">foo() // TypeError: Cannot <span class="built_in">read</span> property <span class="string">'x'</span> of undefined</span><br></pre></td></tr></table></figure></p></blockquote><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo() // undefined 5</span><br></pre></td></tr></table></figure></p><p>上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。</p><blockquote><p>另一个解构赋值默认值的例子。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fetch(url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</span><br><span class="line">// <span class="string">"GET"</span></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure></p></blockquote><p>上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p><blockquote><p>写法推荐<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一 （推荐）</span><br><span class="line"><span class="keyword">function</span> m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">// 写法二</span><br><span class="line"><span class="keyword">function</span> m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x 和 y 都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x 有值，y 无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x 和 y 都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure><p>有参数的情况下，会替换对象解构赋值的默认值。</p><ul><li>参数默认值的位置<blockquote><p>如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line"><span class="keyword">function</span> f(x = 1, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [1, undefined]</span><br><span class="line">f(2) // [2, undefined])</span><br><span class="line">f(, 1) // 报错</span><br><span class="line">f(undefined, 1) // [1, 1]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line"><span class="keyword">function</span> f(x, y = 5, z) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [undefined, 5, undefined]</span><br><span class="line">f(1) // [1, 5, undefined]</span><br><span class="line">f(1, ,2) // 报错</span><br><span class="line">f(1, undefined, 2) // [1, 5, 2]</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</p><p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果,因为使用的是‘===’进行判断。</p><ul><li><p>函数的 length 属性</p><blockquote><p>length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。<br>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。<br>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了</p></blockquote></li><li><p>作用域</p><blockquote><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(x, y = x) &#123;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(2) // 2</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2.<br>当没有定义x时，报错<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> foo(x = x) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></p><p>上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p><p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo = <span class="string">'outer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bar(func = () =&gt; foo) &#123;</span><br><span class="line">  <span class="built_in">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  console.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // outer</span><br></pre></td></tr></table></figure></p><p>函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer</p><p>复杂的例子:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"><span class="keyword">function</span> foo(x, y = <span class="function"><span class="title">function</span></span>() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  var x = 3;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 3</span><br><span class="line">x // 1</span><br></pre></td></tr></table></figure></p><p>函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</p><p>如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"><span class="keyword">function</span> foo(x, y = <span class="function"><span class="title">function</span></span>() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  x = 3;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 2</span><br><span class="line">x // 1</span><br></pre></td></tr></table></figure></p><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><blockquote><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(...values) &#123;</span><br><span class="line">  <span class="built_in">let</span> sum = 0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p></blockquote><blockquote><p>函数的length属性，不包括 rest 参数</p></blockquote><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><blockquote><p>从 ES5 开始，函数内部可以设定为严格模式。<br>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。<br>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p></blockquote><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><blockquote><p>箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。<br>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。<br>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p></blockquote><blockquote><p>箭头函数的一个用处是简化回调函数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正常函数写法</span><br><span class="line">[1,2,3].map(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正常函数写法</span><br><span class="line">var result = values.sort(<span class="keyword">function</span> (a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">var result = values.sort((a, b) =&gt; a - b);</span><br></pre></td></tr></table></figure><p> rest 参数与箭头函数结合的例子。<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> const numbers = (...nums) =&gt; nums;</span><br><span class="line"></span><br><span class="line">numbers(1, 2, 3, 4, 5)</span><br><span class="line">// [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">const headAndTail = (head, ...tail) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(1, 2, 3, 4, 5)</span><br><span class="line">// [1,[2,3,4,5]]</span><br></pre></td></tr></table></figure></p><h4 id="箭头函数注意点"><a href="#箭头函数注意点" class="headerlink" title="箭头函数注意点"></a>箭头函数注意点</h4><blockquote><p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p></blockquote><blockquote><p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p></blockquote><blockquote><p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p></blockquote><blockquote><p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p></blockquote><p>this对象的指向是可变的，但是在箭头函数中，它是固定的。箭头函数导致this总是指向函数定义生效时所在的对象</p><blockquote><p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    document.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; this.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="keyword">function</span>(<span class="built_in">type</span>) &#123;</span><br><span class="line">    console.log(<span class="string">'Handling '</span> + <span class="built_in">type</span>  + <span class="string">' for '</span> + this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><p>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p><blockquote><p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数</p></blockquote><blockquote><p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p></blockquote><blockquote><p>由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p></blockquote><h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p>由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p><blockquote><p>第一个场合是定义函数的方法，且该方法内部包括this。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const cat = &#123;</span><br><span class="line">  lives: 9,</span><br><span class="line">  jumps: () =&gt; &#123;</span><br><span class="line">    this.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>第二个场合是需要动态this的时候，也不应使用箭头函数。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var button = document.getElementById(<span class="string">'press'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  this.classList.toggle(<span class="string">'on'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p></blockquote><h3 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h3><blockquote><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。</p></blockquote><blockquote><p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面</p></blockquote><h3 id="尾调用-尾递归"><a href="#尾调用-尾递归" class="headerlink" title="尾调用 尾递归"></a>尾调用 尾递归</h3><blockquote><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。<br>尾调用不一定出现在函数尾部，只要是最后一步操作即可。<br>函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p></blockquote><blockquote><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。<br>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”</p></blockquote><blockquote><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p></blockquote><blockquote><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p></blockquote><p>递归的改写</p><blockquote><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/function&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&quot;遗留问题-this&quot;&gt;&lt;a href=&quot;#遗留问题-this&quot; class=&quot;headerlink&quot; title=&quot;遗留问题 (this)&quot;&gt;&lt;/a&gt;遗留问题 (this)&lt;/h4&gt;&lt;h2 id=&quot;函数的扩展总结&quot;&gt;&lt;a href=&quot;#函数的扩展总结&quot; class=&quot;headerlink&quot; title=&quot;函数的扩展总结&quot;&gt;&lt;/a&gt;函数的扩展总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本用法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面&lt;br&gt;参数变量是默认声明的，在函数体中，不能用let或const再次声明。&lt;br&gt;使用参数默认值时，函数不能有同名参数。&lt;br&gt;参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;与解构赋值默认值结合使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About es6-变量的解构赋值</title>
    <link href="https://surlyyoung.github.io/2019/03/01/About-es6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://surlyyoung.github.io/2019/03/01/About-es6-变量的解构赋值/</id>
    <published>2019-03-01T08:16:29.000Z</published>
    <updated>2019-03-02T05:12:26.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">Link</a></h3><h2 id="数组的结构赋值-总结"><a href="#数组的结构赋值-总结" class="headerlink" title="数组的结构赋值 总结"></a>数组的结构赋值 总结</h2><blockquote><ul><li>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）</li><li>只要等号两边的模式相同，左边的变量就可以被赋予对应的值</li><li>如果解构不成功(无对应的值)，变量的值就等于undefined</li><li>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功</li><li>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，那么将会报错</li><li>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</li></ul></blockquote><blockquote><ul><li>解构赋值允许指定默认值。</li><li>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined</li><li>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</li><li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li></ul></blockquote><a id="more"></a><h2 id="对象的解构赋值-总结"><a href="#对象的解构赋值-总结" class="headerlink" title="对象的解构赋值 总结"></a>对象的解构赋值 总结</h2><blockquote><ul><li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</li><li>等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined</li></ul></blockquote><blockquote><ul><li>实际上说明，对象的解构赋值是下面形式的简写<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</p><blockquote><ul><li>对象的解构也可以指定默认值。</li><li>默认值生效的条件是，对象的属性值严格等于undefined</li><li>如果解构失败，变量的值等于undefined</li><li>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</li><li>要将一个已经声明的变量用于解构赋值：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line"><span class="built_in">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;; // 解析为代码块</span><br><span class="line">// SyntaxError: syntax error</span><br><span class="line">// 正确的写法</span><br><span class="line"><span class="built_in">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3];</span><br><span class="line"><span class="built_in">let</span> &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”</p><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><blockquote><ul><li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</li><li>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</li></ul></blockquote><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><blockquote><ul><li>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</li></ul></blockquote><h2 id="null和undefined的解构赋值"><a href="#null和undefined的解构赋值" class="headerlink" title="null和undefined的解构赋值"></a>null和undefined的解构赋值</h2><blockquote><ul><li>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错</li></ul></blockquote><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><blockquote><ul><li>函数参数的解构也可以使用默认值。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></p><p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p><blockquote><ul><li>undefined就会触发函数参数的默认值。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, undefined, 3].map((x = <span class="string">'yes'</span>) =&gt; x);</span><br><span class="line">// [ 1, <span class="string">'yes'</span>, 3 ]</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><blockquote><ul><li>只要有可能，就不要在模式中放置圆括号。</li><li>三种解构赋值不得使用圆括号</li></ul><ul><li>（1）变量声明语句</li><li>（2）函数参数</li><li>（3）赋值语句的模式</li></ul></blockquote><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><blockquote><ul><li>交换变量的值<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 1;</span><br><span class="line"><span class="built_in">let</span> y = 2;</span><br><span class="line">[x, y] = [y, x]; //用已定义解构赋值时注意</span><br><span class="line">// 代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>从函数返回多个值<br>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> [a, b, c] = example();</span><br><span class="line">// 返回一个对象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line"><span class="keyword">function</span> f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line"><span class="keyword">function</span> f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>提取 JSON 数据<br>解构赋值对提取 JSON 对象中的数据，尤其有用<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">let</span> &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, <span class="string">"OK"</span>, [867, 5309]</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>函数参数的默认值<br>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="keyword">function</span> (url, &#123;</span><br><span class="line">  async = <span class="literal">true</span>,</span><br><span class="line">  beforeSend = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  // ... <span class="keyword">do</span> stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>遍历 Map 结构<br>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();  //&#123;[key:value],[key:value]&#125;</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</span><br><span class="line">  console.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取键名</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// 获取键值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [,value] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>输入模块的指定方法<br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;数组的结构赋值-总结&quot;&gt;&lt;a href=&quot;#数组的结构赋值-总结&quot; class=&quot;headerlink&quot; title=&quot;数组的结构赋值 总结&quot;&gt;&lt;/a&gt;数组的结构赋值 总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）&lt;/li&gt;
&lt;li&gt;只要等号两边的模式相同，左边的变量就可以被赋予对应的值&lt;/li&gt;
&lt;li&gt;如果解构不成功(无对应的值)，变量的值就等于undefined&lt;/li&gt;
&lt;li&gt;另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功&lt;/li&gt;
&lt;li&gt;如果等号的右边不是数组（或者严格地说，不是可遍历的结构，那么将会报错&lt;/li&gt;
&lt;li&gt;只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;解构赋值允许指定默认值。&lt;/li&gt;
&lt;li&gt;ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined&lt;/li&gt;
&lt;li&gt;如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。&lt;/li&gt;
&lt;li&gt;默认值可以引用解构赋值的其他变量，但该变量必须已经声明&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About ese6-let&amp;const</title>
    <link href="https://surlyyoung.github.io/2019/03/01/About-ese6-let/"/>
    <id>https://surlyyoung.github.io/2019/03/01/About-ese6-let/</id>
    <published>2019-03-01T01:31:28.000Z</published>
    <updated>2019-03-01T08:05:45.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">Link</a></h3><h2 id="let总结"><a href="#let总结" class="headerlink" title="let总结"></a>let总结</h2><blockquote><ul><li>let命令只在代码块中作用，let为 JavaScript 新增了块级作用域，不会出现 因为变量提升而导致内层变量覆盖外层变量，以及 内层变量泄露为全局变量(例如for中)</li><li>for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域，当用let命令在for中定义时，两个作用域不干扰</li><li>let不存在变量提升现象，(即变量可以在声明之前使用，值为undefined，提升至全局上下文顶部或函数上下文顶部)，故let命令声明的变量一定要声明后使用</li><li>let存在暂时性死区（temporal dead zone，简称 TDZ），即在块级作用域里，使用let命令声明变量的代码之前，该变量不可用（不论在这之前是否有同名的全局变量）</li><li>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</li><li>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为</li><li>在用let命令声明的变量之前，使用typeof检测其变量类型会出错而不是undefined</li><li>let不允许在相同作用域内，重复声明同一个变量</li><li>ES6 允许块级作用域的任意嵌套</li><li>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要</li></ul></blockquote><a id="more"></a><blockquote><ul><li>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明，但浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数</li><li>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用，同时只在使用大括号的情况下成立，如果没有使用大括号，就会报错</li><li>而实际在浏览器的 ES6 环境中为了减轻产生的不兼容问题，块级作用域内声明的函数，行为类似于var声明的变量，将 函数的声明 提升至 全局作用域 或函数作用域的头部 或块级作用域的头部</li></ul></blockquote><h2 id="const总结"><a href="#const总结" class="headerlink" title="const总结"></a>const总结</h2><blockquote><ul><li>与let一样不可重复声明</li><li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li><li>const声明一个只读的常量。一旦声明，常量的值就不能改变，意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错</li><li>const不能改变的时变量指向的内存地址所保存的数据，对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</li><li>如果真的想将对象冻结，应该使用Object.freeze方法。如果真的想将对象冻结，应该使用Object.freeze方法。</li></ul></blockquote><h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><blockquote><ul><li>ES5 只有两种声明变量的方法：var命令和function命令</li><li>ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令</li></ul></blockquote><h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2><blockquote><ul><li>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。</li><li>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；</li><li>另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;let总结&quot;&gt;&lt;a href=&quot;#let总结&quot; class=&quot;headerlink&quot; title=&quot;let总结&quot;&gt;&lt;/a&gt;let总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;let命令只在代码块中作用，let为 JavaScript 新增了块级作用域，不会出现 因为变量提升而导致内层变量覆盖外层变量，以及 内层变量泄露为全局变量(例如for中)&lt;/li&gt;
&lt;li&gt;for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域，当用let命令在for中定义时，两个作用域不干扰&lt;/li&gt;
&lt;li&gt;let不存在变量提升现象，(即变量可以在声明之前使用，值为undefined，提升至全局上下文顶部或函数上下文顶部)，故let命令声明的变量一定要声明后使用&lt;/li&gt;
&lt;li&gt;let存在暂时性死区（temporal dead zone，简称 TDZ），即在块级作用域里，使用let命令声明变量的代码之前，该变量不可用（不论在这之前是否有同名的全局变量）&lt;/li&gt;
&lt;li&gt;暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量&lt;/li&gt;
&lt;li&gt;ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为&lt;/li&gt;
&lt;li&gt;在用let命令声明的变量之前，使用typeof检测其变量类型会出错而不是undefined&lt;/li&gt;
&lt;li&gt;let不允许在相同作用域内，重复声明同一个变量&lt;/li&gt;
&lt;li&gt;ES6 允许块级作用域的任意嵌套&lt;/li&gt;
&lt;li&gt;块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About async &amp; await</title>
    <link href="https://surlyyoung.github.io/2019/02/28/async-await/"/>
    <id>https://surlyyoung.github.io/2019/02/28/async-await/</id>
    <published>2019-02-28T01:32:19.000Z</published>
    <updated>2019-02-28T08:57:15.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">Link</a></h3><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><blockquote><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便<br>async 函数是什么？一句话，它就是 Generator 函数的语法糖,async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await<br>async函数对 Generator 函数的改进，体现在以下四点:</p><ul><li>内置执行器 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行</li><li>更好的语义 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果</li><li>更广的适用性 async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）</li><li>返回值是 Promise  async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖</li></ul></blockquote><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><blockquote><p>async函数返回一个 Promise 对象(await跟的是promise对象)，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br>async 函数有多种使用形式<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line"><span class="built_in">let</span> obj = &#123; async <span class="function"><span class="title">foo</span></span>() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().<span class="keyword">then</span>(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    <span class="built_in">return</span> cache.match(`/avatars/<span class="variable">$&#123;name&#125;</span>.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).<span class="keyword">then</span>(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>async函数(隐式)返回一个 Promise 对象。<br>async函数内部return语句返回的值，会成为then方法回调函数的参数。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(</span><br><span class="line">  v =&gt; console.log(v),</span><br><span class="line">  e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="async函数的promise的状态转化"><a href="#async函数的promise的状态转化" class="headerlink" title="async函数的promise的状态转化"></a>async函数的promise的状态转化</h2><blockquote><p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p></blockquote><h2 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h2><blockquote><p>正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  // 等同于</span><br><span class="line">  // <span class="built_in">return</span> 123;</span><br><span class="line">  <span class="built_in">return</span> await 123;</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Sleep &#123;</span><br><span class="line">  constructor(timeout) &#123;</span><br><span class="line">    this.timeout = timeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">then</span>(resolve, reject) &#123;</span><br><span class="line">    const startTime = Date.now();</span><br><span class="line">    setTimeout(</span><br><span class="line">      () =&gt; resolve(Date.now() - startTime),</span><br><span class="line">      this.timeout</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  const actualTime = await new Sleep(1000);</span><br><span class="line">  console.log(actualTime);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  // 等同于 await <span class="built_in">return</span> Promise.reject(<span class="string">'出事了'</span>)</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  await Promise.resolve(<span class="string">'hello world'</span>); // 不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。如果有多个await命令，可以统一放在try…catch结构中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  // 等同于不加<span class="built_in">return</span> </span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(e =&gt; console.log(e));</span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 出错了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><blockquote><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><ol><li><p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="keyword">function</span> (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="built_in">let</span> [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="built_in">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="built_in">let</span> barPromise = getBar();</span><br><span class="line"><span class="built_in">let</span> foo = await fooPromise;</span><br><span class="line"><span class="built_in">let</span> bar = await barPromise;</span><br></pre></td></tr></table></figure></li><li><p>await命令只能用在async函数之中，如果用在普通函数，就会报错。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(<span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> dbFuc(db) &#123; //这里不需要 async</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 可能得到错误结果</span><br><span class="line">  docs.forEach(async <span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>正确的写法是采用for循环。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> doc of docs) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>async 函数可以保留运行堆栈<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = async () =&gt; &#123;</span><br><span class="line">  await b();</span><br><span class="line">  c();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。</p><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><blockquote><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> fn(args) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(args) &#123;</span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。</p><h2 id="与其他异步处理方法的比较-async-函数与-Promise、Generator-函数的比较"><a href="#与其他异步处理方法的比较-async-函数与-Promise、Generator-函数的比较" class="headerlink" title="与其他异步处理方法的比较 async 函数与 Promise、Generator 函数的比较"></a>与其他异步处理方法的比较 async 函数与 Promise、Generator 函数的比较</h2><ul><li>Promise 的语义不佳</li><li>Generator语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。</li><li>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</li></ul><h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><blockquote><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果<br>Promise 的写法如下不太直观，可读性比较差:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 远程读取所有URL</span><br><span class="line">  const textPromises = urls.map(url =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> fetch(url).<span class="keyword">then</span>(response =&gt; response.text());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  textPromises.reduce((chain, textPromise) =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> chain.then(() =&gt; textPromise)</span><br><span class="line">      .<span class="keyword">then</span>(text =&gt; console.log(text));</span><br><span class="line">  &#125;, Promise.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p> async 函数实现。<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 上面所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。、<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 并发读取远程URL</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    <span class="built_in">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  <span class="keyword">for</span> (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/async&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ES2017 标准引入了 async 函数，使得异步操作变得更加方便&lt;br&gt;async 函数是什么？一句话，它就是 Generator 函数的语法糖,async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await&lt;br&gt;async函数对 Generator 函数的改进，体现在以下四点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置执行器 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行&lt;/li&gt;
&lt;li&gt;更好的语义 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果&lt;/li&gt;
&lt;li&gt;更广的适用性 async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）&lt;/li&gt;
&lt;li&gt;返回值是 Promise  async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About Iterator &amp; for of</title>
    <link href="https://surlyyoung.github.io/2019/02/27/About-Iterator-for-of/"/>
    <id>https://surlyyoung.github.io/2019/02/27/About-Iterator-for-of/</id>
    <published>2019-02-27T09:07:23.000Z</published>
    <updated>2019-02-28T08:57:09.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Link</a></h3><h2 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h2><blockquote><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。</p></blockquote><blockquote><p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p></blockquote><blockquote><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p></blockquote><a id="more"></a><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器\<br>for…of循环可以代替数组实例的forEach方法<br>for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性,非数字索引会自动忽略</p></blockquote><h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><blockquote><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for…of循环<br>Set 结构遍历时，返回的是一个值 (同数组)，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值</p></blockquote><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><blockquote><p>for…of循环可用于字符串、DOM NodeList 对象、arguments对象</p></blockquote><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><blockquote><p>对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但，for…in循环依然可以用来遍历键名<br>一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var key of Object.keys(someObject)) &#123;</span><br><span class="line">  console.log(key + <span class="string">': '</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><blockquote><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环<br>这种写法比较麻烦，因此数组提供内置的forEach方法。这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。<br>for…in循环可以遍历数组的键名. 同时有几个缺点：</p><ul><li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等</li><li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键，理论上较消耗性能</li><li>某些情况下，for…in循环会以任意顺序遍历键名<br>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组</li></ul></blockquote><p>for…of循环相比上面几种做法，有一些显著的优点：</p><ul><li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li><li>不同于forEach方法，它可以与break、continue和return配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/iterator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;for-of-循环&quot;&gt;&lt;a href=&quot;#for-of-循环&quot; class=&quot;headerlink&quot; title=&quot;for of 循环&quot;&gt;&lt;/a&gt;for of 循环&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About Promise</title>
    <link href="https://surlyyoung.github.io/2019/02/27/About-Promise/"/>
    <id>https://surlyyoung.github.io/2019/02/27/About-Promise/</id>
    <published>2019-02-27T03:37:03.000Z</published>
    <updated>2019-02-28T08:57:46.439Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Link</a></h3><h2 id="Basic-useage"><a href="#Basic-useage" class="headerlink" title="Basic useage"></a>Basic useage</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var promise1 = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  var obj = &#123;code:200,message:<span class="string">'ok'</span>,data:<span class="string">''</span>&#125;</span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span>() &#123; //发起请求，请求处理（异步操作）</span><br><span class="line">    resolve(obj); //成功之后</span><br><span class="line">  &#125;, 300);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">  // expected output: &#123; code: 200, message: <span class="string">"ok"</span>, data: <span class="string">""</span> &#125;</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(e)&#123;console.log(e)&#125;);</span><br><span class="line"></span><br><span class="line">console.log(promise1);</span><br><span class="line">// expected output: [object Promise]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise( <span class="keyword">function</span>(resolve, reject) &#123;...&#125; /* executor */  );</span><br></pre></td></tr></table></figure><h3 id="参数-executor"><a href="#参数-executor" class="headerlink" title="参数 executor"></a>参数 executor</h3><blockquote><p>executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。<br>如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p></blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p></blockquote><blockquote><p>一个 Promise有以下几种状态:</p><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Promise.all(iterable)</p><blockquote><p>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败</p></blockquote><p>Promise.race(iterable)</p><blockquote><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p></blockquote><p>Promise.reject(reason)</p><blockquote><p>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p></blockquote><p>Promise.resolve(value)</p><blockquote><p>返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用</p></blockquote><h2 id="Promise-原型"><a href="#Promise-原型" class="headerlink" title="Promise 原型"></a>Promise 原型</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>Promise.prototype.constructor</li></ul><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li>Promise.prototype.catch(onRejected)</li><li>Promise.prototype.then(onFulfilled, onRejected)</li><li>Promise.prototype.finally(onFinally)</li></ul><h2 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h2><blockquote><p>Promise 对象是由关键字 new 及其构造函数来创建的。该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，去调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，去调用reject 函数。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myFirstPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // ?做一些异步操作，最终会调用下面两者之一:</span><br><span class="line">  //</span><br><span class="line">  //   resolve(someValue); // fulfilled</span><br><span class="line">  // ?或</span><br><span class="line">  //   reject(<span class="string">"failure reason"</span>); // rejected</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>想要某个函数?拥有promise功能，只需让其返回一个promise即可。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> myAsyncFunction(url) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    xhr.onload = () =&gt; resolve(xhr.responseText);</span><br><span class="line">    xhr.onerror = () =&gt; reject(xhr.statusText);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="高级示例-使用XHR-和-promise-加载图像"><a href="#高级示例-使用XHR-和-promise-加载图像" class="headerlink" title="高级示例 使用XHR 和 promise 加载图像"></a>高级示例 使用XHR 和 promise 加载图像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> imgLoad(url) &#123;</span><br><span class="line">    // Create new promise with the Promise() constructor;</span><br><span class="line">    // This has as its argument a <span class="keyword">function</span></span><br><span class="line">    // with two parameters, resolve and reject</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">        // Standard XHR to load an image</span><br><span class="line">    var request = new XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.responseType = <span class="string">'blob'</span>;</span><br><span class="line">       // When the request loads, check whether it was successful</span><br><span class="line">    request.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (request.status === 200) &#123;</span><br><span class="line">         // If successful, resolve the promise by passing back the request response</span><br><span class="line">        resolve(request.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // If it fails, reject the promise with a error message</span><br><span class="line">        reject(Error(<span class="string">'Image didn\'</span>t load successfully; error code:<span class="string">' + request.statusText));</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    request.onerror = function() &#123;</span></span><br><span class="line"><span class="string">      // Also deal with the case when the entire request fails to begin with</span></span><br><span class="line"><span class="string">      // This is probably a network error, so reject the promise with an appropriate message</span></span><br><span class="line"><span class="string">        reject(Error('</span>There was a network error.<span class="string">'));</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">     // Send the request</span></span><br><span class="line"><span class="string">    request.send();</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">  // Get a reference to the body element, and create a new image object</span></span><br><span class="line"><span class="string">var body = document.querySelector('</span>body<span class="string">');</span></span><br><span class="line"><span class="string">var myImage = new Image();</span></span><br><span class="line"><span class="string">  // Call the function with the URL we want to load, but then chain the</span></span><br><span class="line"><span class="string">  // promise then() method on to the end of it. This contains two callbacks</span></span><br><span class="line"><span class="string">imgLoad('</span>myLittleVader.jpg<span class="string">').then(function(response) &#123;</span></span><br><span class="line"><span class="string">    // The first runs when the promise resolves, with the request.response</span></span><br><span class="line"><span class="string">    // specified within the resolve() method.</span></span><br><span class="line"><span class="string">  var imageURL = window.URL.createObjectURL(response);</span></span><br><span class="line"><span class="string">  myImage.src = imageURL;</span></span><br><span class="line"><span class="string">  body.appendChild(myImage);</span></span><br><span class="line"><span class="string">    // The second runs when the promise</span></span><br><span class="line"><span class="string">    // is rejected, and logs the Error specified with the reject() method.</span></span><br><span class="line"><span class="string">&#125;, function(Error) &#123;</span></span><br><span class="line"><span class="string">  console.log(Error);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</li><li>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;Basic-useage&quot;&gt;&lt;a href=&quot;#Basic-useage&quot; class=&quot;headerlink&quot; title=&quot;Basic useage&quot;&gt;&lt;/a&gt;Basic useage&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var promise1 = new Promise(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(resolve, reject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var obj = &amp;#123;code:200,message:&lt;span class=&quot;string&quot;&gt;&#39;ok&#39;&lt;/span&gt;,data:&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123; //发起请求，请求处理（异步操作）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve(obj); //成功之后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;promise1.then(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // expected output: &amp;#123; code: 200, message: &lt;span class=&quot;string&quot;&gt;&quot;ok&quot;&lt;/span&gt;, data: &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(e)&amp;#123;console.log(e)&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(promise1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// expected output: [object Promise]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第三篇文章</title>
    <link href="https://surlyyoung.github.io/2019/02/22/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>https://surlyyoung.github.io/2019/02/22/第三篇文章/</id>
    <published>2019-02-22T09:18:39.000Z</published>
    <updated>2019-02-22T09:20:25.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言-hexo-new-生成的-会出现在主页"><a href="#前言-hexo-new-生成的-会出现在主页" class="headerlink" title="前言 hexo new 生成的 会出现在主页"></a>前言 hexo new 生成的 会出现在主页</h1><h2 id="使用github-pages服务搭建博客的好处有："><a href="#使用github-pages服务搭建博客的好处有：" class="headerlink" title="使用github pages服务搭建博客的好处有："></a>使用github pages服务搭建博客的好处有：</h2><h3 id="这是第三条博客"><a href="#这是第三条博客" class="headerlink" title="这是第三条博客"></a>这是第三条博客</h3><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li></ol><a id="more"></a><ol start="4"><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>等等；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言-hexo-new-生成的-会出现在主页&quot;&gt;&lt;a href=&quot;#前言-hexo-new-生成的-会出现在主页&quot; class=&quot;headerlink&quot; title=&quot;前言 hexo new 生成的 会出现在主页&quot;&gt;&lt;/a&gt;前言 hexo new 生成的 会出现在主页&lt;/h1&gt;&lt;h2 id=&quot;使用github-pages服务搭建博客的好处有：&quot;&gt;&lt;a href=&quot;#使用github-pages服务搭建博客的好处有：&quot; class=&quot;headerlink&quot; title=&quot;使用github pages服务搭建博客的好处有：&quot;&gt;&lt;/a&gt;使用github pages服务搭建博客的好处有：&lt;/h2&gt;&lt;h3 id=&quot;这是第三条博客&quot;&gt;&lt;a href=&quot;#这是第三条博客&quot; class=&quot;headerlink&quot; title=&quot;这是第三条博客&quot;&gt;&lt;/a&gt;这是第三条博客&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;全是静态文件，访问速度快；&lt;/li&gt;
&lt;li&gt;免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;/li&gt;
&lt;li&gt;可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>try again</title>
    <link href="https://surlyyoung.github.io/2019/02/22/try-again/"/>
    <id>https://surlyyoung.github.io/2019/02/22/try-again/</id>
    <published>2019-02-22T07:31:01.000Z</published>
    <updated>2019-02-22T07:35:12.976Z</updated>
    
    <content type="html"><![CDATA[<p>try to connent surlyyoung.github.io</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;try to connent surlyyoung.github.io&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>first time  writing in my blog</title>
    <link href="https://surlyyoung.github.io/2019/02/22/first-time-writing-in-my-blog/"/>
    <id>https://surlyyoung.github.io/2019/02/22/first-time-writing-in-my-blog/</id>
    <published>2019-02-22T07:03:09.000Z</published>
    <updated>2019-02-22T07:05:08.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this-is-my-first-time-writing-in-my-blog"><a href="#this-is-my-first-time-writing-in-my-blog" class="headerlink" title="this is my first time writing in my blog!"></a>this is my first time writing in my blog!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this-is-my-first-time-writing-in-my-blog&quot;&gt;&lt;a href=&quot;#this-is-my-first-time-writing-in-my-blog&quot; class=&quot;headerlink&quot; title=&quot;this is my f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://surlyyoung.github.io/2019/02/22/hello-world/"/>
    <id>https://surlyyoung.github.io/2019/02/22/hello-world/</id>
    <published>2019-02-22T06:44:25.619Z</published>
    <updated>2019-02-22T06:44:25.619Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
