<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Surly 的 blog</title>
  
  <subtitle>it is ok</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://surlyyoung.github.io/"/>
  <updated>2019-03-02T04:59:31.342Z</updated>
  <id>https://surlyyoung.github.io/</id>
  
  <author>
    <name>Surly Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>About es6-变量的解构赋值</title>
    <link href="https://surlyyoung.github.io/2019/03/01/About-es6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://surlyyoung.github.io/2019/03/01/About-es6-变量的解构赋值/</id>
    <published>2019-03-01T08:16:29.000Z</published>
    <updated>2019-03-02T04:59:31.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">Link</a></h3><h2 id="数组的结构赋值-总结"><a href="#数组的结构赋值-总结" class="headerlink" title="数组的结构赋值 总结"></a>数组的结构赋值 总结</h2><blockquote><ul><li>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）</li><li>只要等号两边的模式相同，左边的变量就可以被赋予对应的值</li><li>如果解构不成功(无对应的值)，变量的值就等于undefined</li><li>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功</li><li>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，那么将会报错</li><li>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</li></ul></blockquote><blockquote><ul><li>解构赋值允许指定默认值。</li><li>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined</li><li>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</li><li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li></ul></blockquote><a id="more"></a><h2 id="对象的解构赋值-总结"><a href="#对象的解构赋值-总结" class="headerlink" title="对象的解构赋值 总结"></a>对象的解构赋值 总结</h2><blockquote><ul><li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</li><li>等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined</li></ul></blockquote><blockquote><ul><li>实际上说明，对象的解构赋值是下面形式的简写<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</p><blockquote><ul><li>对象的解构也可以指定默认值。</li><li>默认值生效的条件是，对象的属性值严格等于undefined</li><li>如果解构失败，变量的值等于undefined</li><li>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</li><li>要将一个已经声明的变量用于解构赋值：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line"><span class="built_in">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;; // 解析为代码块</span><br><span class="line">// SyntaxError: syntax error</span><br><span class="line">// 正确的写法</span><br><span class="line"><span class="built_in">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3];</span><br><span class="line"><span class="built_in">let</span> &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”</p><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><blockquote><ul><li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</li><li>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</li></ul></blockquote><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><blockquote><ul><li>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</li></ul></blockquote><h2 id="null和undefined的解构赋值"><a href="#null和undefined的解构赋值" class="headerlink" title="null和undefined的解构赋值"></a>null和undefined的解构赋值</h2><blockquote><ul><li>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错</li></ul></blockquote><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><blockquote><ul><li>函数参数的解构也可以使用默认值。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></p><p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p><blockquote><ul><li>undefined就会触发函数参数的默认值。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, undefined, 3].map((x = <span class="string">'yes'</span>) =&gt; x);</span><br><span class="line">// [ 1, <span class="string">'yes'</span>, 3 ]</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><blockquote><ul><li>只要有可能，就不要在模式中放置圆括号。</li><li>三种解构赋值不得使用圆括号</li></ul><ul><li>（1）变量声明语句</li><li>（2）函数参数</li><li>（3）赋值语句的模式</li></ul></blockquote><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><blockquote><ul><li>交换变量的值<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 1;</span><br><span class="line"><span class="built_in">let</span> y = 2;</span><br><span class="line">[x, y] = [y, x]; //用已定义解构赋值时注意</span><br><span class="line">// 代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>从函数返回多个值<br>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> [a, b, c] = example();</span><br><span class="line">// 返回一个对象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line"><span class="keyword">function</span> f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line"><span class="keyword">function</span> f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>提取 JSON 数据<br>解构赋值对提取 JSON 对象中的数据，尤其有用<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">let</span> &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, <span class="string">"OK"</span>, [867, 5309]</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>函数参数的默认值<br>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="keyword">function</span> (url, &#123;</span><br><span class="line">  async = <span class="literal">true</span>,</span><br><span class="line">  beforeSend = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  // ... <span class="keyword">do</span> stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>遍历 Map 结构<br>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map(); &#123;[key:value],[key:value]&#125;</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</span><br><span class="line">  console.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取键名</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// 获取键值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [,value] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>输入模块的指定方法<br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;数组的结构赋值-总结&quot;&gt;&lt;a href=&quot;#数组的结构赋值-总结&quot; class=&quot;headerlink&quot; title=&quot;数组的结构赋值 总结&quot;&gt;&lt;/a&gt;数组的结构赋值 总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）&lt;/li&gt;
&lt;li&gt;只要等号两边的模式相同，左边的变量就可以被赋予对应的值&lt;/li&gt;
&lt;li&gt;如果解构不成功(无对应的值)，变量的值就等于undefined&lt;/li&gt;
&lt;li&gt;另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功&lt;/li&gt;
&lt;li&gt;如果等号的右边不是数组（或者严格地说，不是可遍历的结构，那么将会报错&lt;/li&gt;
&lt;li&gt;只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;解构赋值允许指定默认值。&lt;/li&gt;
&lt;li&gt;ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined&lt;/li&gt;
&lt;li&gt;如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。&lt;/li&gt;
&lt;li&gt;默认值可以引用解构赋值的其他变量，但该变量必须已经声明&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About ese6-let&amp;const</title>
    <link href="https://surlyyoung.github.io/2019/03/01/About-ese6-let/"/>
    <id>https://surlyyoung.github.io/2019/03/01/About-ese6-let/</id>
    <published>2019-03-01T01:31:28.000Z</published>
    <updated>2019-03-01T08:05:45.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">Link</a></h3><h2 id="let总结"><a href="#let总结" class="headerlink" title="let总结"></a>let总结</h2><blockquote><ul><li>let命令只在代码块中作用，let为 JavaScript 新增了块级作用域，不会出现 因为变量提升而导致内层变量覆盖外层变量，以及 内层变量泄露为全局变量(例如for中)</li><li>for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域，当用let命令在for中定义时，两个作用域不干扰</li><li>let不存在变量提升现象，(即变量可以在声明之前使用，值为undefined，提升至全局上下文顶部或函数上下文顶部)，故let命令声明的变量一定要声明后使用</li><li>let存在暂时性死区（temporal dead zone，简称 TDZ），即在块级作用域里，使用let命令声明变量的代码之前，该变量不可用（不论在这之前是否有同名的全局变量）</li><li>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</li><li>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为</li><li>在用let命令声明的变量之前，使用typeof检测其变量类型会出错而不是undefined</li><li>let不允许在相同作用域内，重复声明同一个变量</li><li>ES6 允许块级作用域的任意嵌套</li><li>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要</li></ul></blockquote><a id="more"></a><blockquote><ul><li>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明，但浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数</li><li>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用，同时只在使用大括号的情况下成立，如果没有使用大括号，就会报错</li><li>而实际在浏览器的 ES6 环境中为了减轻产生的不兼容问题，块级作用域内声明的函数，行为类似于var声明的变量，将 函数的声明 提升至 全局作用域 或函数作用域的头部 或块级作用域的头部</li></ul></blockquote><h2 id="const总结"><a href="#const总结" class="headerlink" title="const总结"></a>const总结</h2><blockquote><ul><li>与let一样不可重复声明</li><li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li><li>const声明一个只读的常量。一旦声明，常量的值就不能改变，意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错</li><li>const不能改变的时变量指向的内存地址所保存的数据，对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</li><li>如果真的想将对象冻结，应该使用Object.freeze方法。如果真的想将对象冻结，应该使用Object.freeze方法。</li></ul></blockquote><h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><blockquote><ul><li>ES5 只有两种声明变量的方法：var命令和function命令</li><li>ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令</li></ul></blockquote><h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2><blockquote><ul><li>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。</li><li>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；</li><li>另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;let总结&quot;&gt;&lt;a href=&quot;#let总结&quot; class=&quot;headerlink&quot; title=&quot;let总结&quot;&gt;&lt;/a&gt;let总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;let命令只在代码块中作用，let为 JavaScript 新增了块级作用域，不会出现 因为变量提升而导致内层变量覆盖外层变量，以及 内层变量泄露为全局变量(例如for中)&lt;/li&gt;
&lt;li&gt;for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域，当用let命令在for中定义时，两个作用域不干扰&lt;/li&gt;
&lt;li&gt;let不存在变量提升现象，(即变量可以在声明之前使用，值为undefined，提升至全局上下文顶部或函数上下文顶部)，故let命令声明的变量一定要声明后使用&lt;/li&gt;
&lt;li&gt;let存在暂时性死区（temporal dead zone，简称 TDZ），即在块级作用域里，使用let命令声明变量的代码之前，该变量不可用（不论在这之前是否有同名的全局变量）&lt;/li&gt;
&lt;li&gt;暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量&lt;/li&gt;
&lt;li&gt;ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为&lt;/li&gt;
&lt;li&gt;在用let命令声明的变量之前，使用typeof检测其变量类型会出错而不是undefined&lt;/li&gt;
&lt;li&gt;let不允许在相同作用域内，重复声明同一个变量&lt;/li&gt;
&lt;li&gt;ES6 允许块级作用域的任意嵌套&lt;/li&gt;
&lt;li&gt;块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About async &amp; await</title>
    <link href="https://surlyyoung.github.io/2019/02/28/async-await/"/>
    <id>https://surlyyoung.github.io/2019/02/28/async-await/</id>
    <published>2019-02-28T01:32:19.000Z</published>
    <updated>2019-02-28T08:57:15.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">Link</a></h3><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><blockquote><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便<br>async 函数是什么？一句话，它就是 Generator 函数的语法糖,async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await<br>async函数对 Generator 函数的改进，体现在以下四点:</p><ul><li>内置执行器 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行</li><li>更好的语义 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果</li><li>更广的适用性 async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）</li><li>返回值是 Promise  async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖</li></ul></blockquote><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><blockquote><p>async函数返回一个 Promise 对象(await跟的是promise对象)，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br>async 函数有多种使用形式<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line"><span class="built_in">let</span> obj = &#123; async <span class="function"><span class="title">foo</span></span>() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().<span class="keyword">then</span>(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    <span class="built_in">return</span> cache.match(`/avatars/<span class="variable">$&#123;name&#125;</span>.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).<span class="keyword">then</span>(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>async函数(隐式)返回一个 Promise 对象。<br>async函数内部return语句返回的值，会成为then方法回调函数的参数。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(</span><br><span class="line">  v =&gt; console.log(v),</span><br><span class="line">  e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="async函数的promise的状态转化"><a href="#async函数的promise的状态转化" class="headerlink" title="async函数的promise的状态转化"></a>async函数的promise的状态转化</h2><blockquote><p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p></blockquote><h2 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h2><blockquote><p>正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  // 等同于</span><br><span class="line">  // <span class="built_in">return</span> 123;</span><br><span class="line">  <span class="built_in">return</span> await 123;</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Sleep &#123;</span><br><span class="line">  constructor(timeout) &#123;</span><br><span class="line">    this.timeout = timeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">then</span>(resolve, reject) &#123;</span><br><span class="line">    const startTime = Date.now();</span><br><span class="line">    setTimeout(</span><br><span class="line">      () =&gt; resolve(Date.now() - startTime),</span><br><span class="line">      this.timeout</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  const actualTime = await new Sleep(1000);</span><br><span class="line">  console.log(actualTime);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  // 等同于 await <span class="built_in">return</span> Promise.reject(<span class="string">'出事了'</span>)</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  await Promise.resolve(<span class="string">'hello world'</span>); // 不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。如果有多个await命令，可以统一放在try…catch结构中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  // 等同于不加<span class="built_in">return</span> </span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(e =&gt; console.log(e));</span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 出错了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><blockquote><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><ol><li><p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="keyword">function</span> (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="built_in">let</span> [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="built_in">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="built_in">let</span> barPromise = getBar();</span><br><span class="line"><span class="built_in">let</span> foo = await fooPromise;</span><br><span class="line"><span class="built_in">let</span> bar = await barPromise;</span><br></pre></td></tr></table></figure></li><li><p>await命令只能用在async函数之中，如果用在普通函数，就会报错。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(<span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> dbFuc(db) &#123; //这里不需要 async</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 可能得到错误结果</span><br><span class="line">  docs.forEach(async <span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>正确的写法是采用for循环。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> doc of docs) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>async 函数可以保留运行堆栈<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = async () =&gt; &#123;</span><br><span class="line">  await b();</span><br><span class="line">  c();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。</p><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><blockquote><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> fn(args) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(args) &#123;</span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。</p><h2 id="与其他异步处理方法的比较-async-函数与-Promise、Generator-函数的比较"><a href="#与其他异步处理方法的比较-async-函数与-Promise、Generator-函数的比较" class="headerlink" title="与其他异步处理方法的比较 async 函数与 Promise、Generator 函数的比较"></a>与其他异步处理方法的比较 async 函数与 Promise、Generator 函数的比较</h2><ul><li>Promise 的语义不佳</li><li>Generator语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。</li><li>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</li></ul><h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><blockquote><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果<br>Promise 的写法如下不太直观，可读性比较差:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 远程读取所有URL</span><br><span class="line">  const textPromises = urls.map(url =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> fetch(url).<span class="keyword">then</span>(response =&gt; response.text());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  textPromises.reduce((chain, textPromise) =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> chain.then(() =&gt; textPromise)</span><br><span class="line">      .<span class="keyword">then</span>(text =&gt; console.log(text));</span><br><span class="line">  &#125;, Promise.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p> async 函数实现。<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 上面所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。、<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 并发读取远程URL</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    <span class="built_in">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  <span class="keyword">for</span> (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/async&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ES2017 标准引入了 async 函数，使得异步操作变得更加方便&lt;br&gt;async 函数是什么？一句话，它就是 Generator 函数的语法糖,async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await&lt;br&gt;async函数对 Generator 函数的改进，体现在以下四点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置执行器 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行&lt;/li&gt;
&lt;li&gt;更好的语义 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果&lt;/li&gt;
&lt;li&gt;更广的适用性 async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）&lt;/li&gt;
&lt;li&gt;返回值是 Promise  async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About Iterator &amp; for of</title>
    <link href="https://surlyyoung.github.io/2019/02/27/About-Iterator-for-of/"/>
    <id>https://surlyyoung.github.io/2019/02/27/About-Iterator-for-of/</id>
    <published>2019-02-27T09:07:23.000Z</published>
    <updated>2019-02-28T08:57:09.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Link</a></h3><h2 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h2><blockquote><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。</p></blockquote><blockquote><p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p></blockquote><blockquote><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p></blockquote><a id="more"></a><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器\<br>for…of循环可以代替数组实例的forEach方法<br>for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性,非数字索引会自动忽略</p></blockquote><h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><blockquote><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for…of循环<br>Set 结构遍历时，返回的是一个值 (同数组)，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值</p></blockquote><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><blockquote><p>for…of循环可用于字符串、DOM NodeList 对象、arguments对象</p></blockquote><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><blockquote><p>对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但，for…in循环依然可以用来遍历键名<br>一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var key of Object.keys(someObject)) &#123;</span><br><span class="line">  console.log(key + <span class="string">': '</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><blockquote><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环<br>这种写法比较麻烦，因此数组提供内置的forEach方法。这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。<br>for…in循环可以遍历数组的键名. 同时有几个缺点：</p><ul><li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等</li><li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键，理论上较消耗性能</li><li>某些情况下，for…in循环会以任意顺序遍历键名<br>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组</li></ul></blockquote><p>for…of循环相比上面几种做法，有一些显著的优点：</p><ul><li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li><li>不同于forEach方法，它可以与break、continue和return配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/iterator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;for-of-循环&quot;&gt;&lt;a href=&quot;#for-of-循环&quot; class=&quot;headerlink&quot; title=&quot;for of 循环&quot;&gt;&lt;/a&gt;for of 循环&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About Promise</title>
    <link href="https://surlyyoung.github.io/2019/02/27/About-Promise/"/>
    <id>https://surlyyoung.github.io/2019/02/27/About-Promise/</id>
    <published>2019-02-27T03:37:03.000Z</published>
    <updated>2019-02-28T08:57:46.439Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Link</a></h3><h2 id="Basic-useage"><a href="#Basic-useage" class="headerlink" title="Basic useage"></a>Basic useage</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var promise1 = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  var obj = &#123;code:200,message:<span class="string">'ok'</span>,data:<span class="string">''</span>&#125;</span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span>() &#123; //发起请求，请求处理（异步操作）</span><br><span class="line">    resolve(obj); //成功之后</span><br><span class="line">  &#125;, 300);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">  // expected output: &#123; code: 200, message: <span class="string">"ok"</span>, data: <span class="string">""</span> &#125;</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(e)&#123;console.log(e)&#125;);</span><br><span class="line"></span><br><span class="line">console.log(promise1);</span><br><span class="line">// expected output: [object Promise]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise( <span class="keyword">function</span>(resolve, reject) &#123;...&#125; /* executor */  );</span><br></pre></td></tr></table></figure><h3 id="参数-executor"><a href="#参数-executor" class="headerlink" title="参数 executor"></a>参数 executor</h3><blockquote><p>executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。<br>如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p></blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p></blockquote><blockquote><p>一个 Promise有以下几种状态:</p><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Promise.all(iterable)</p><blockquote><p>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败</p></blockquote><p>Promise.race(iterable)</p><blockquote><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p></blockquote><p>Promise.reject(reason)</p><blockquote><p>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p></blockquote><p>Promise.resolve(value)</p><blockquote><p>返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用</p></blockquote><h2 id="Promise-原型"><a href="#Promise-原型" class="headerlink" title="Promise 原型"></a>Promise 原型</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>Promise.prototype.constructor</li></ul><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li>Promise.prototype.catch(onRejected)</li><li>Promise.prototype.then(onFulfilled, onRejected)</li><li>Promise.prototype.finally(onFinally)</li></ul><h2 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h2><blockquote><p>Promise 对象是由关键字 new 及其构造函数来创建的。该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，去调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，去调用reject 函数。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myFirstPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // ?做一些异步操作，最终会调用下面两者之一:</span><br><span class="line">  //</span><br><span class="line">  //   resolve(someValue); // fulfilled</span><br><span class="line">  // ?或</span><br><span class="line">  //   reject(<span class="string">"failure reason"</span>); // rejected</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>想要某个函数?拥有promise功能，只需让其返回一个promise即可。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> myAsyncFunction(url) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    xhr.onload = () =&gt; resolve(xhr.responseText);</span><br><span class="line">    xhr.onerror = () =&gt; reject(xhr.statusText);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="高级示例-使用XHR-和-promise-加载图像"><a href="#高级示例-使用XHR-和-promise-加载图像" class="headerlink" title="高级示例 使用XHR 和 promise 加载图像"></a>高级示例 使用XHR 和 promise 加载图像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> imgLoad(url) &#123;</span><br><span class="line">    // Create new promise with the Promise() constructor;</span><br><span class="line">    // This has as its argument a <span class="keyword">function</span></span><br><span class="line">    // with two parameters, resolve and reject</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">        // Standard XHR to load an image</span><br><span class="line">    var request = new XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.responseType = <span class="string">'blob'</span>;</span><br><span class="line">       // When the request loads, check whether it was successful</span><br><span class="line">    request.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (request.status === 200) &#123;</span><br><span class="line">         // If successful, resolve the promise by passing back the request response</span><br><span class="line">        resolve(request.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // If it fails, reject the promise with a error message</span><br><span class="line">        reject(Error(<span class="string">'Image didn\'</span>t load successfully; error code:<span class="string">' + request.statusText));</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    request.onerror = function() &#123;</span></span><br><span class="line"><span class="string">      // Also deal with the case when the entire request fails to begin with</span></span><br><span class="line"><span class="string">      // This is probably a network error, so reject the promise with an appropriate message</span></span><br><span class="line"><span class="string">        reject(Error('</span>There was a network error.<span class="string">'));</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">     // Send the request</span></span><br><span class="line"><span class="string">    request.send();</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">  // Get a reference to the body element, and create a new image object</span></span><br><span class="line"><span class="string">var body = document.querySelector('</span>body<span class="string">');</span></span><br><span class="line"><span class="string">var myImage = new Image();</span></span><br><span class="line"><span class="string">  // Call the function with the URL we want to load, but then chain the</span></span><br><span class="line"><span class="string">  // promise then() method on to the end of it. This contains two callbacks</span></span><br><span class="line"><span class="string">imgLoad('</span>myLittleVader.jpg<span class="string">').then(function(response) &#123;</span></span><br><span class="line"><span class="string">    // The first runs when the promise resolves, with the request.response</span></span><br><span class="line"><span class="string">    // specified within the resolve() method.</span></span><br><span class="line"><span class="string">  var imageURL = window.URL.createObjectURL(response);</span></span><br><span class="line"><span class="string">  myImage.src = imageURL;</span></span><br><span class="line"><span class="string">  body.appendChild(myImage);</span></span><br><span class="line"><span class="string">    // The second runs when the promise</span></span><br><span class="line"><span class="string">    // is rejected, and logs the Error specified with the reject() method.</span></span><br><span class="line"><span class="string">&#125;, function(Error) &#123;</span></span><br><span class="line"><span class="string">  console.log(Error);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</li><li>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;Basic-useage&quot;&gt;&lt;a href=&quot;#Basic-useage&quot; class=&quot;headerlink&quot; title=&quot;Basic useage&quot;&gt;&lt;/a&gt;Basic useage&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var promise1 = new Promise(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(resolve, reject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var obj = &amp;#123;code:200,message:&lt;span class=&quot;string&quot;&gt;&#39;ok&#39;&lt;/span&gt;,data:&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123; //发起请求，请求处理（异步操作）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve(obj); //成功之后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;promise1.then(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // expected output: &amp;#123; code: 200, message: &lt;span class=&quot;string&quot;&gt;&quot;ok&quot;&lt;/span&gt;, data: &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(e)&amp;#123;console.log(e)&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(promise1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// expected output: [object Promise]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第三篇文章</title>
    <link href="https://surlyyoung.github.io/2019/02/22/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>https://surlyyoung.github.io/2019/02/22/第三篇文章/</id>
    <published>2019-02-22T09:18:39.000Z</published>
    <updated>2019-02-22T09:20:25.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言-hexo-new-生成的-会出现在主页"><a href="#前言-hexo-new-生成的-会出现在主页" class="headerlink" title="前言 hexo new 生成的 会出现在主页"></a>前言 hexo new 生成的 会出现在主页</h1><h2 id="使用github-pages服务搭建博客的好处有："><a href="#使用github-pages服务搭建博客的好处有：" class="headerlink" title="使用github pages服务搭建博客的好处有："></a>使用github pages服务搭建博客的好处有：</h2><h3 id="这是第三条博客"><a href="#这是第三条博客" class="headerlink" title="这是第三条博客"></a>这是第三条博客</h3><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li></ol><a id="more"></a><ol start="4"><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>等等；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言-hexo-new-生成的-会出现在主页&quot;&gt;&lt;a href=&quot;#前言-hexo-new-生成的-会出现在主页&quot; class=&quot;headerlink&quot; title=&quot;前言 hexo new 生成的 会出现在主页&quot;&gt;&lt;/a&gt;前言 hexo new 生成的 会出现在主页&lt;/h1&gt;&lt;h2 id=&quot;使用github-pages服务搭建博客的好处有：&quot;&gt;&lt;a href=&quot;#使用github-pages服务搭建博客的好处有：&quot; class=&quot;headerlink&quot; title=&quot;使用github pages服务搭建博客的好处有：&quot;&gt;&lt;/a&gt;使用github pages服务搭建博客的好处有：&lt;/h2&gt;&lt;h3 id=&quot;这是第三条博客&quot;&gt;&lt;a href=&quot;#这是第三条博客&quot; class=&quot;headerlink&quot; title=&quot;这是第三条博客&quot;&gt;&lt;/a&gt;这是第三条博客&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;全是静态文件，访问速度快；&lt;/li&gt;
&lt;li&gt;免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;/li&gt;
&lt;li&gt;可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>try again</title>
    <link href="https://surlyyoung.github.io/2019/02/22/try-again/"/>
    <id>https://surlyyoung.github.io/2019/02/22/try-again/</id>
    <published>2019-02-22T07:31:01.000Z</published>
    <updated>2019-02-22T07:35:12.976Z</updated>
    
    <content type="html"><![CDATA[<p>try to connent surlyyoung.github.io</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;try to connent surlyyoung.github.io&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>first time  writing in my blog</title>
    <link href="https://surlyyoung.github.io/2019/02/22/first-time-writing-in-my-blog/"/>
    <id>https://surlyyoung.github.io/2019/02/22/first-time-writing-in-my-blog/</id>
    <published>2019-02-22T07:03:09.000Z</published>
    <updated>2019-02-22T07:05:08.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this-is-my-first-time-writing-in-my-blog"><a href="#this-is-my-first-time-writing-in-my-blog" class="headerlink" title="this is my first time writing in my blog!"></a>this is my first time writing in my blog!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this-is-my-first-time-writing-in-my-blog&quot;&gt;&lt;a href=&quot;#this-is-my-first-time-writing-in-my-blog&quot; class=&quot;headerlink&quot; title=&quot;this is my f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://surlyyoung.github.io/2019/02/22/hello-world/"/>
    <id>https://surlyyoung.github.io/2019/02/22/hello-world/</id>
    <published>2019-02-22T06:44:25.619Z</published>
    <updated>2019-02-22T06:44:25.619Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
