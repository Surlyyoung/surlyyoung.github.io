<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Surly 的 blog</title>
  
  <subtitle>it is ok</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://surlyyoung.github.io/"/>
  <updated>2019-03-01T08:00:36.040Z</updated>
  <id>https://surlyyoung.github.io/</id>
  
  <author>
    <name>Surly Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>About ese6-let&amp;const</title>
    <link href="https://surlyyoung.github.io/2019/03/01/About-ese6-let/"/>
    <id>https://surlyyoung.github.io/2019/03/01/About-ese6-let/</id>
    <published>2019-03-01T01:31:28.000Z</published>
    <updated>2019-03-01T08:00:36.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">Link</a></h3><h2 id="let总结"><a href="#let总结" class="headerlink" title="let总结"></a>let总结</h2><blockquote><p>let命令只在代码块中作用，let为 JavaScript 新增了块级作用域，不会出现 因为变量提升而导致内层变量覆盖外层变量，以及 内层变量泄露为全局变量(例如for中)<br>for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域，当用let命令在for中定义时，两个作用域不干扰<br>let不存在变量提升现象，(即变量可以在声明之前使用，值为undefined，提升至全局上下文顶部或函数上下文顶部)，故let命令声明的变量一定要声明后使用<br>let存在暂时性死区（temporal dead zone，简称 TDZ），即在块级作用域里，使用let命令声明变量的代码之前，该变量不可用（不论在这之前是否有同名的全局变量）<br>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量<br>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为<br>在用let命令声明的变量之前，使用typeof检测其变量类型会出错而不是undefined<br>let不允许在相同作用域内，重复声明同一个变量<br>ES6 允许块级作用域的任意嵌套<br>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要</p></blockquote><a id="more"></a><blockquote><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明，但浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数<br>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用，同时只在使用大括号的情况下成立，如果没有使用大括号，就会报错<br>而实际在浏览器的 ES6 环境中为了减轻产生的不兼容问题，块级作用域内声明的函数，行为类似于var声明的变量，将函数的声明提升至提升到全局作用域或函数作用域的头部或块级作用域的头部</p></blockquote><h2 id="const总结"><a href="#const总结" class="headerlink" title="const总结"></a>const总结</h2><blockquote><p>与let一样不可重复声明<br>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br>const声明一个只读的常量。一旦声明，常量的值就不能改变，意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错<br>const不能改变的时变量指向的内存地址所保存的数据，对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。<br>如果真的想将对象冻结，应该使用Object.freeze方法。如果真的想将对象冻结，应该使用Object.freeze方法。</p></blockquote><h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><blockquote><p>ES5 只有两种声明变量的方法：var命令和function命令<br>ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令</p></blockquote><h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2><blockquote><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<br>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；<br>另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;let总结&quot;&gt;&lt;a href=&quot;#let总结&quot; class=&quot;headerlink&quot; title=&quot;let总结&quot;&gt;&lt;/a&gt;let总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;let命令只在代码块中作用，let为 JavaScript 新增了块级作用域，不会出现 因为变量提升而导致内层变量覆盖外层变量，以及 内层变量泄露为全局变量(例如for中)&lt;br&gt;for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域，当用let命令在for中定义时，两个作用域不干扰&lt;br&gt;let不存在变量提升现象，(即变量可以在声明之前使用，值为undefined，提升至全局上下文顶部或函数上下文顶部)，故let命令声明的变量一定要声明后使用&lt;br&gt;let存在暂时性死区（temporal dead zone，简称 TDZ），即在块级作用域里，使用let命令声明变量的代码之前，该变量不可用（不论在这之前是否有同名的全局变量）&lt;br&gt;暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量&lt;br&gt;ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为&lt;br&gt;在用let命令声明的变量之前，使用typeof检测其变量类型会出错而不是undefined&lt;br&gt;let不允许在相同作用域内，重复声明同一个变量&lt;br&gt;ES6 允许块级作用域的任意嵌套&lt;br&gt;块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About async &amp; await</title>
    <link href="https://surlyyoung.github.io/2019/02/28/async-await/"/>
    <id>https://surlyyoung.github.io/2019/02/28/async-await/</id>
    <published>2019-02-28T01:32:19.000Z</published>
    <updated>2019-02-28T08:57:15.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">Link</a></h3><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><blockquote><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便<br>async 函数是什么？一句话，它就是 Generator 函数的语法糖,async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await<br>async函数对 Generator 函数的改进，体现在以下四点:</p><ul><li>内置执行器 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行</li><li>更好的语义 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果</li><li>更广的适用性 async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）</li><li>返回值是 Promise  async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖</li></ul></blockquote><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><blockquote><p>async函数返回一个 Promise 对象(await跟的是promise对象)，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br>async 函数有多种使用形式<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line"><span class="built_in">let</span> obj = &#123; async <span class="function"><span class="title">foo</span></span>() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().<span class="keyword">then</span>(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    <span class="built_in">return</span> cache.match(`/avatars/<span class="variable">$&#123;name&#125;</span>.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).<span class="keyword">then</span>(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>async函数(隐式)返回一个 Promise 对象。<br>async函数内部return语句返回的值，会成为then方法回调函数的参数。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(</span><br><span class="line">  v =&gt; console.log(v),</span><br><span class="line">  e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="async函数的promise的状态转化"><a href="#async函数的promise的状态转化" class="headerlink" title="async函数的promise的状态转化"></a>async函数的promise的状态转化</h2><blockquote><p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p></blockquote><h2 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h2><blockquote><p>正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  // 等同于</span><br><span class="line">  // <span class="built_in">return</span> 123;</span><br><span class="line">  <span class="built_in">return</span> await 123;</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Sleep &#123;</span><br><span class="line">  constructor(timeout) &#123;</span><br><span class="line">    this.timeout = timeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">then</span>(resolve, reject) &#123;</span><br><span class="line">    const startTime = Date.now();</span><br><span class="line">    setTimeout(</span><br><span class="line">      () =&gt; resolve(Date.now() - startTime),</span><br><span class="line">      this.timeout</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  const actualTime = await new Sleep(1000);</span><br><span class="line">  console.log(actualTime);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  // 等同于 await <span class="built_in">return</span> Promise.reject(<span class="string">'出事了'</span>)</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  await Promise.resolve(<span class="string">'hello world'</span>); // 不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。如果有多个await命令，可以统一放在try…catch结构中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  // 等同于不加<span class="built_in">return</span> </span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(e =&gt; console.log(e));</span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 出错了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><blockquote><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><ol><li><p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="keyword">function</span> (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="built_in">let</span> [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="built_in">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="built_in">let</span> barPromise = getBar();</span><br><span class="line"><span class="built_in">let</span> foo = await fooPromise;</span><br><span class="line"><span class="built_in">let</span> bar = await barPromise;</span><br></pre></td></tr></table></figure></li><li><p>await命令只能用在async函数之中，如果用在普通函数，就会报错。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(<span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> dbFuc(db) &#123; //这里不需要 async</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 可能得到错误结果</span><br><span class="line">  docs.forEach(async <span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>正确的写法是采用for循环。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> doc of docs) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>async 函数可以保留运行堆栈<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = async () =&gt; &#123;</span><br><span class="line">  await b();</span><br><span class="line">  c();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。</p><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><blockquote><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> fn(args) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(args) &#123;</span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。</p><h2 id="与其他异步处理方法的比较-async-函数与-Promise、Generator-函数的比较"><a href="#与其他异步处理方法的比较-async-函数与-Promise、Generator-函数的比较" class="headerlink" title="与其他异步处理方法的比较 async 函数与 Promise、Generator 函数的比较"></a>与其他异步处理方法的比较 async 函数与 Promise、Generator 函数的比较</h2><ul><li>Promise 的语义不佳</li><li>Generator语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。</li><li>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</li></ul><h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><blockquote><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果<br>Promise 的写法如下不太直观，可读性比较差:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 远程读取所有URL</span><br><span class="line">  const textPromises = urls.map(url =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> fetch(url).<span class="keyword">then</span>(response =&gt; response.text());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  textPromises.reduce((chain, textPromise) =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> chain.then(() =&gt; textPromise)</span><br><span class="line">      .<span class="keyword">then</span>(text =&gt; console.log(text));</span><br><span class="line">  &#125;, Promise.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p> async 函数实现。<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 上面所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。、<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 并发读取远程URL</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    <span class="built_in">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  <span class="keyword">for</span> (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/async&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ES2017 标准引入了 async 函数，使得异步操作变得更加方便&lt;br&gt;async 函数是什么？一句话，它就是 Generator 函数的语法糖,async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await&lt;br&gt;async函数对 Generator 函数的改进，体现在以下四点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置执行器 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行&lt;/li&gt;
&lt;li&gt;更好的语义 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果&lt;/li&gt;
&lt;li&gt;更广的适用性 async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）&lt;/li&gt;
&lt;li&gt;返回值是 Promise  async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About Iterator &amp; for of</title>
    <link href="https://surlyyoung.github.io/2019/02/27/About-Iterator-for-of/"/>
    <id>https://surlyyoung.github.io/2019/02/27/About-Iterator-for-of/</id>
    <published>2019-02-27T09:07:23.000Z</published>
    <updated>2019-02-28T08:57:09.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Link</a></h3><h2 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h2><blockquote><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。</p></blockquote><blockquote><p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p></blockquote><blockquote><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p></blockquote><a id="more"></a><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器\<br>for…of循环可以代替数组实例的forEach方法<br>for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性,非数字索引会自动忽略</p></blockquote><h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><blockquote><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for…of循环<br>Set 结构遍历时，返回的是一个值 (同数组)，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值</p></blockquote><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><blockquote><p>for…of循环可用于字符串、DOM NodeList 对象、arguments对象</p></blockquote><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><blockquote><p>对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但，for…in循环依然可以用来遍历键名<br>一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var key of Object.keys(someObject)) &#123;</span><br><span class="line">  console.log(key + <span class="string">': '</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><blockquote><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环<br>这种写法比较麻烦，因此数组提供内置的forEach方法。这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。<br>for…in循环可以遍历数组的键名. 同时有几个缺点：</p><ul><li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等</li><li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键，理论上较消耗性能</li><li>某些情况下，for…in循环会以任意顺序遍历键名<br>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组</li></ul></blockquote><p>for…of循环相比上面几种做法，有一些显著的优点：</p><ul><li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li><li>不同于forEach方法，它可以与break、continue和return配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/iterator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;for-of-循环&quot;&gt;&lt;a href=&quot;#for-of-循环&quot; class=&quot;headerlink&quot; title=&quot;for of 循环&quot;&gt;&lt;/a&gt;for of 循环&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>About Promise</title>
    <link href="https://surlyyoung.github.io/2019/02/27/About-Promise/"/>
    <id>https://surlyyoung.github.io/2019/02/27/About-Promise/</id>
    <published>2019-02-27T03:37:03.000Z</published>
    <updated>2019-02-28T08:57:46.439Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章-Link"><a href="#参考文章-Link" class="headerlink" title="参考文章 Link"></a>参考文章 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Link</a></h3><h2 id="Basic-useage"><a href="#Basic-useage" class="headerlink" title="Basic useage"></a>Basic useage</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var promise1 = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  var obj = &#123;code:200,message:<span class="string">'ok'</span>,data:<span class="string">''</span>&#125;</span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span>() &#123; //发起请求，请求处理（异步操作）</span><br><span class="line">    resolve(obj); //成功之后</span><br><span class="line">  &#125;, 300);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">  // expected output: &#123; code: 200, message: <span class="string">"ok"</span>, data: <span class="string">""</span> &#125;</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(e)&#123;console.log(e)&#125;);</span><br><span class="line"></span><br><span class="line">console.log(promise1);</span><br><span class="line">// expected output: [object Promise]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise( <span class="keyword">function</span>(resolve, reject) &#123;...&#125; /* executor */  );</span><br></pre></td></tr></table></figure><h3 id="参数-executor"><a href="#参数-executor" class="headerlink" title="参数 executor"></a>参数 executor</h3><blockquote><p>executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。<br>如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p></blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p></blockquote><blockquote><p>一个 Promise有以下几种状态:</p><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Promise.all(iterable)</p><blockquote><p>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败</p></blockquote><p>Promise.race(iterable)</p><blockquote><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p></blockquote><p>Promise.reject(reason)</p><blockquote><p>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p></blockquote><p>Promise.resolve(value)</p><blockquote><p>返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用</p></blockquote><h2 id="Promise-原型"><a href="#Promise-原型" class="headerlink" title="Promise 原型"></a>Promise 原型</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>Promise.prototype.constructor</li></ul><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li>Promise.prototype.catch(onRejected)</li><li>Promise.prototype.then(onFulfilled, onRejected)</li><li>Promise.prototype.finally(onFinally)</li></ul><h2 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h2><blockquote><p>Promise 对象是由关键字 new 及其构造函数来创建的。该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，去调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，去调用reject 函数。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myFirstPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // ?做一些异步操作，最终会调用下面两者之一:</span><br><span class="line">  //</span><br><span class="line">  //   resolve(someValue); // fulfilled</span><br><span class="line">  // ?或</span><br><span class="line">  //   reject(<span class="string">"failure reason"</span>); // rejected</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>想要某个函数?拥有promise功能，只需让其返回一个promise即可。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> myAsyncFunction(url) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    xhr.onload = () =&gt; resolve(xhr.responseText);</span><br><span class="line">    xhr.onerror = () =&gt; reject(xhr.statusText);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="高级示例-使用XHR-和-promise-加载图像"><a href="#高级示例-使用XHR-和-promise-加载图像" class="headerlink" title="高级示例 使用XHR 和 promise 加载图像"></a>高级示例 使用XHR 和 promise 加载图像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> imgLoad(url) &#123;</span><br><span class="line">    // Create new promise with the Promise() constructor;</span><br><span class="line">    // This has as its argument a <span class="keyword">function</span></span><br><span class="line">    // with two parameters, resolve and reject</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">        // Standard XHR to load an image</span><br><span class="line">    var request = new XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.responseType = <span class="string">'blob'</span>;</span><br><span class="line">       // When the request loads, check whether it was successful</span><br><span class="line">    request.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (request.status === 200) &#123;</span><br><span class="line">         // If successful, resolve the promise by passing back the request response</span><br><span class="line">        resolve(request.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // If it fails, reject the promise with a error message</span><br><span class="line">        reject(Error(<span class="string">'Image didn\'</span>t load successfully; error code:<span class="string">' + request.statusText));</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    request.onerror = function() &#123;</span></span><br><span class="line"><span class="string">      // Also deal with the case when the entire request fails to begin with</span></span><br><span class="line"><span class="string">      // This is probably a network error, so reject the promise with an appropriate message</span></span><br><span class="line"><span class="string">        reject(Error('</span>There was a network error.<span class="string">'));</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">     // Send the request</span></span><br><span class="line"><span class="string">    request.send();</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">  // Get a reference to the body element, and create a new image object</span></span><br><span class="line"><span class="string">var body = document.querySelector('</span>body<span class="string">');</span></span><br><span class="line"><span class="string">var myImage = new Image();</span></span><br><span class="line"><span class="string">  // Call the function with the URL we want to load, but then chain the</span></span><br><span class="line"><span class="string">  // promise then() method on to the end of it. This contains two callbacks</span></span><br><span class="line"><span class="string">imgLoad('</span>myLittleVader.jpg<span class="string">').then(function(response) &#123;</span></span><br><span class="line"><span class="string">    // The first runs when the promise resolves, with the request.response</span></span><br><span class="line"><span class="string">    // specified within the resolve() method.</span></span><br><span class="line"><span class="string">  var imageURL = window.URL.createObjectURL(response);</span></span><br><span class="line"><span class="string">  myImage.src = imageURL;</span></span><br><span class="line"><span class="string">  body.appendChild(myImage);</span></span><br><span class="line"><span class="string">    // The second runs when the promise</span></span><br><span class="line"><span class="string">    // is rejected, and logs the Error specified with the reject() method.</span></span><br><span class="line"><span class="string">&#125;, function(Error) &#123;</span></span><br><span class="line"><span class="string">  console.log(Error);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</li><li>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文章-Link&quot;&gt;&lt;a href=&quot;#参考文章-Link&quot; class=&quot;headerlink&quot; title=&quot;参考文章 Link&quot;&gt;&lt;/a&gt;参考文章 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;Basic-useage&quot;&gt;&lt;a href=&quot;#Basic-useage&quot; class=&quot;headerlink&quot; title=&quot;Basic useage&quot;&gt;&lt;/a&gt;Basic useage&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var promise1 = new Promise(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(resolve, reject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var obj = &amp;#123;code:200,message:&lt;span class=&quot;string&quot;&gt;&#39;ok&#39;&lt;/span&gt;,data:&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123; //发起请求，请求处理（异步操作）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve(obj); //成功之后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;promise1.then(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // expected output: &amp;#123; code: 200, message: &lt;span class=&quot;string&quot;&gt;&quot;ok&quot;&lt;/span&gt;, data: &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(e)&amp;#123;console.log(e)&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(promise1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// expected output: [object Promise]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第三篇文章</title>
    <link href="https://surlyyoung.github.io/2019/02/22/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>https://surlyyoung.github.io/2019/02/22/第三篇文章/</id>
    <published>2019-02-22T09:18:39.000Z</published>
    <updated>2019-02-22T09:20:25.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言-hexo-new-生成的-会出现在主页"><a href="#前言-hexo-new-生成的-会出现在主页" class="headerlink" title="前言 hexo new 生成的 会出现在主页"></a>前言 hexo new 生成的 会出现在主页</h1><h2 id="使用github-pages服务搭建博客的好处有："><a href="#使用github-pages服务搭建博客的好处有：" class="headerlink" title="使用github pages服务搭建博客的好处有："></a>使用github pages服务搭建博客的好处有：</h2><h3 id="这是第三条博客"><a href="#这是第三条博客" class="headerlink" title="这是第三条博客"></a>这是第三条博客</h3><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li></ol><a id="more"></a><ol start="4"><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>等等；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言-hexo-new-生成的-会出现在主页&quot;&gt;&lt;a href=&quot;#前言-hexo-new-生成的-会出现在主页&quot; class=&quot;headerlink&quot; title=&quot;前言 hexo new 生成的 会出现在主页&quot;&gt;&lt;/a&gt;前言 hexo new 生成的 会出现在主页&lt;/h1&gt;&lt;h2 id=&quot;使用github-pages服务搭建博客的好处有：&quot;&gt;&lt;a href=&quot;#使用github-pages服务搭建博客的好处有：&quot; class=&quot;headerlink&quot; title=&quot;使用github pages服务搭建博客的好处有：&quot;&gt;&lt;/a&gt;使用github pages服务搭建博客的好处有：&lt;/h2&gt;&lt;h3 id=&quot;这是第三条博客&quot;&gt;&lt;a href=&quot;#这是第三条博客&quot; class=&quot;headerlink&quot; title=&quot;这是第三条博客&quot;&gt;&lt;/a&gt;这是第三条博客&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;全是静态文件，访问速度快；&lt;/li&gt;
&lt;li&gt;免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;/li&gt;
&lt;li&gt;可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>try again</title>
    <link href="https://surlyyoung.github.io/2019/02/22/try-again/"/>
    <id>https://surlyyoung.github.io/2019/02/22/try-again/</id>
    <published>2019-02-22T07:31:01.000Z</published>
    <updated>2019-02-22T07:35:12.976Z</updated>
    
    <content type="html"><![CDATA[<p>try to connent surlyyoung.github.io</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;try to connent surlyyoung.github.io&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>first time  writing in my blog</title>
    <link href="https://surlyyoung.github.io/2019/02/22/first-time-writing-in-my-blog/"/>
    <id>https://surlyyoung.github.io/2019/02/22/first-time-writing-in-my-blog/</id>
    <published>2019-02-22T07:03:09.000Z</published>
    <updated>2019-02-22T07:05:08.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this-is-my-first-time-writing-in-my-blog"><a href="#this-is-my-first-time-writing-in-my-blog" class="headerlink" title="this is my first time writing in my blog!"></a>this is my first time writing in my blog!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this-is-my-first-time-writing-in-my-blog&quot;&gt;&lt;a href=&quot;#this-is-my-first-time-writing-in-my-blog&quot; class=&quot;headerlink&quot; title=&quot;this is my f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://surlyyoung.github.io/2019/02/22/hello-world/"/>
    <id>https://surlyyoung.github.io/2019/02/22/hello-world/</id>
    <published>2019-02-22T06:44:25.619Z</published>
    <updated>2019-02-22T06:44:25.619Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
